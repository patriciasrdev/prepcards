let currentCardIndex = 0;

const flashcards = [
    { question: "What are the primitive data types in JavaScript?", answer: "Number, String, Boolean, Undefined, Null, Symbol" },
    { question: "Explain the difference between let, const, and var in JavaScript.", answer: "let and const have block scope, while var has function scope. const variables cannot be reassigned after declaration." },
    { question: "What is the difference between == and === in JavaScript?", answer: "== performs type coercion, while === performs strict equality comparison without type conversion." },
    { question: "What are closures in JavaScript? Provide an example.", answer: "Closures are functions that remember the environment in which they were created. They have access to variables in their outer scope even after the outer function has finished executing.\n\nExample:\nfunction outerFunction() {\n    const outerVariable = 'I am outer';\n    return function innerFunction() {\n        console.log(outerVariable);\n    };\n}\nconst innerFunc = outerFunction();\ninnerFunc(); // Output: 'I am outer'" },
    { question: "How does asynchronous programming work in JavaScript?", answer: "JavaScript uses an event loop to handle asynchronous operations. Promises, async/await, and callbacks are common ways to manage asynchronous code execution and handle asynchronous tasks like fetching data or waiting for timers." },
    { question: "What is the difference between synchronous and asynchronous code execution?", answer: "Synchronous code executes line by line, blocking further execution until each line has finished. Asynchronous code allows tasks to be executed separately, and the program can continue to run while waiting for tasks to complete." },
    { question: "Explain the concept of hoisting in JavaScript.", answer: "Hoisting is a JavaScript behavior where variable and function declarations are moved to the top of their containing scope during the compilation phase. This allows variables to be used before they are declared, but it's recommended to declare variables before using them for clarity." },
    { question: "What are Arrow Functions in JavaScript? How do they differ from regular functions?", answer: "Arrow functions are a concise syntax for writing functions in JavaScript. They do not have their own `this` context and cannot be used as constructors. Arrow functions are more suitable for non-method functions and provide implicit return for single expressions." },
    { question: "How do you handle errors in JavaScript? Explain try...catch and error propagation.", answer: "Errors in JavaScript can be handled using try...catch blocks to catch and handle exceptions. The catch block executes when an error occurs within the try block. Error propagation involves throwing and catching errors to control program flow and handle exceptional cases." },
    { question: "Explain the difference between null and undefined in JavaScript.", answer: "`null` represents the intentional absence of any object value, while `undefined` represents a variable that has been declared but not assigned a value. `null` is explicitly assigned, while `undefined` is typically the default value of uninitialized variables." },
    { question: "What is React? Explain its key features and advantages.", answer: "React is a JavaScript library for building user interfaces. Its key features include virtual DOM for efficient rendering, component-based architecture, JSX for declarative UI, and one-way data binding. React enables building reusable and composable UI components, facilitating a more maintainable and efficient development process." },
    { question: "Describe the difference between functional components and class components in React.", answer: "Functional components are JavaScript functions that receive props and return React elements. They are simpler and more lightweight, introduced in React Hooks as the preferred way to write components. Class components are ES6 classes that extend `React.Component`, providing additional features like state management and lifecycle methods." },
    { question: "What are Props in React? How are they used to pass data between components?", answer: "Props (short for properties) are a way to pass data from parent to child components in React. They are immutable and help in creating reusable components by making them configurable. Props are passed as attributes to child components and accessed using `this.props` within class components or as function arguments in functional components." },
    { question: "What are Hooks in React? Explain some commonly used hooks like useState and useEffect.", answer: "Hooks are functions that enable functional components to use state and lifecycle features in React. `useState` is a hook for adding state to functional components, while `useEffect` is used for handling side effects (e.g., fetching data, subscribing to events) in functional components. Hooks allow developers to use React features in functional components without using class components." },
    { question: "What is JSX in React? How does it differ from regular HTML?", answer: "JSX (JavaScript XML) is a syntax extension for JavaScript used with React to describe UI components. It resembles HTML but is actually JavaScript. JSX allows mixing HTML-like code with JavaScript logic, making React components more readable and expressive. JSX elements are transpiled to `React.createElement()` calls before rendering." },
    { question: "Explain the concept of state in React. How do you manage state in functional components?", answer: "State in React represents the mutable data that affects a component's rendering. Functional components can use the `useState` hook to add local state management. The `useState` hook returns a state variable and a function to update that variable. State should be used to store data that may change over time within a component." },
    { question: "What is the purpose of key prop in React lists? Why is it important?", answer: "The `key` prop is used to uniquely identify elements in a React list. It helps React identify which items have changed, are added, or are removed in a list of components. Using a unique `key` for each item improves rendering performance and maintains component state correctly during updates." },
    { question: "What is event delegation in JavaScript? How is it used?", answer: "Event delegation is a technique where a single event listener is attached to a parent element to manage events for all of its descendants. This helps reduce the number of event listeners and can improve performance, especially for dynamically added elements or lists of items." },
    { question: "Describe the concept of prop drilling in React. How can it be avoided?", answer: "Prop drilling refers to passing props through multiple layers of nested components, which can make components less reusable and harder to maintain. To avoid prop drilling, you can use state management solutions like React Context or Redux to share data across components without passing props manually through each level." },
    { question: "What are controlled components in React? Explain with an example.", answer: "Controlled components in React are form elements whose value is controlled by React state. The input value is set as a state variable and updated through `onChange` events. This allows React to manage and validate form input statefully.\n\nExample:\nfunction MyForm() {\n    const [inputValue, setInputValue] = useState('');\n    const handleChange = (e) => {\n        setInputValue(e.target.value);\n    };\n    return (\n        <input type='text' value={inputValue} onChange={handleChange} />\n    );\n}" },
    { question: "What is the virtual DOM in React? How does it improve performance?", answer: "The virtual DOM (Document Object Model) is an in-memory representation of the actual DOM elements in a web page. React uses the virtual DOM to perform efficient updates by comparing the current virtual DOM with the previous one and only applying the necessary changes to the real DOM. This reduces DOM manipulation overhead and improves rendering performance." },
    { question: "Explain the concept of component lifecycle in React.", answer: "Component lifecycle refers to the series of phases that a React component goes through from initialization to destruction. The lifecycle methods include `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`. These methods allow developers to perform actions at specific points in a component's life, such as fetching data, updating state, or cleaning up resources." },
    { question: "What is the role of keys in React lists? Why are they important?", answer: "Keys are special string attributes used by React to identify unique DOM elements within arrays of children. Keys help React identify which items have changed, been added, or been removed in lists. Using keys correctly ensures efficient updates and maintains component state correctly during re-rendering." },
    { question: "What is the difference between state and props in React?", answer: "State is managed within a component and can be updated using setState(), while props are passed into a component and are immutable. State is internal and specific to a component, whereas props are external and passed down from parent components." },
    { question: "Explain the concept of higher-order components (HOCs) in React.", answer: "Higher-order components are functions that take a component as an argument and return a new component with extended functionality. HOCs are used for code reuse, logic abstraction, and cross-cutting concerns like authentication or data fetching." },
    { question: "What is the significance of the `this` keyword in JavaScript?", answer: "The `this` keyword refers to the current execution context in JavaScript. Its value depends on how a function is called: in the global scope, `this` refers to the global object (window in browsers); in a function, `this` refers to the object that owns the function; and in arrow functions, `this` is lexically scoped to the enclosing function." },
    { question: "How can you optimize performance in React applications?", answer: "Performance optimizations in React can be achieved by using techniques like memoization, minimizing re-renders using shouldComponentUpdate or React.memo, lazy loading components with React.lazy and Suspense, code splitting, and optimizing network requests with GraphQL or REST." },
    { question: "Explain the concept of context in React. When would you use it?", answer: "Context in React provides a way to pass data through the component tree without having to pass props manually at every level. It's useful for sharing data that is considered global, such as themes, user authentication, or language preferences. Context is particularly beneficial for avoiding prop drilling in deeply nested component trees." },
    { question: "What is the purpose of useEffect hook in React?", answer: "The useEffect hook in React is used to perform side effects in functional components. It replaces lifecycle methods like componentDidMount, componentDidUpdate, and componentWillUnmount. useEffect runs after rendering and can be used for data fetching, subscriptions, or DOM manipulations." },
    { question: "What are React Fragments? Why are they used?", answer: "React Fragments allow grouping multiple React elements without adding extra nodes to the DOM. They are used to avoid unnecessary wrapper elements when returning multiple components from a component render method. Fragments help keep the component hierarchy clean and improve performance." },
    { question: "Explain the concept of lazy loading in React.", answer: "Lazy loading in React is a technique used to defer the loading of non-essential resources at the initial render. React.lazy and Suspense are used to load components lazily, reducing the initial bundle size and improving performance by loading components only when they are needed." },
    { question: "What is the purpose of a reducer in React?", answer: "A reducer in React is a pure function used to manage state transitions in complex components or applications. It takes the current state and an action as input and returns a new state based on the action type. Reducers are commonly used with the useReducer hook for managing more complex state logic." },
    { question: "How does React Router work? Explain its key components.", answer: "React Router is a popular library for routing in React applications. It uses a declarative approach to define routes and map them to components. Key components include BrowserRouter for web applications, Route for defining routes, Link for navigation, and Switch for rendering the first matching route." },
    { question: "What are the benefits of using Redux with React?", answer: "Redux is a predictable state container for JavaScript applications, commonly used with React for managing global application state. Benefits of using Redux include centralized state management, predictable data flow, time-travel debugging, and easier testing of components." },
    { question: "Explain the concept of immutability in React. Why is it important?", answer: "Immutability means that once an object is created, it cannot be changed. In React, immutability is important for performance optimizations like shallow comparisons for shouldComponentUpdate or React.memo. Immutable data structures enable efficient state updates without mutating the original data, helping to prevent bugs and side effects." },
    { question: "What are the differences between class components and functional components prior to React Hooks?", answer: "Before the introduction of React Hooks, class components were used for stateful components with lifecycle methods. Functional components were stateless and used for rendering UI based on props. Class components had access to lifecycle methods like componentDidMount and setState, while functional components lacked state management capabilities." },
    { question: "Explain the concept of PureComponent in React. How does it differ from regular components?", answer: "PureComponent is a class component in React that implements shouldComponentUpdate with a shallow prop and state comparison to prevent unnecessary re-renders. It is useful for optimizing performance in applications where components render frequently." },
    { question: "What is the significance of the virtual DOM in React?", answer: "The virtual DOM (Document Object Model) in React is a lightweight copy of the actual DOM. React uses the virtual DOM to perform efficient updates by comparing the current virtual DOM with the previous one and only applying the necessary changes to the real DOM. This approach minimizes DOM manipulations and improves rendering performance." },
    { question: "What is the significance of the virtual DOM in React?", answer: "The virtual DOM (Document Object Model) in React is a lightweight copy of the actual DOM. React uses the virtual DOM to perform efficient updates by comparing the current virtual DOM with the previous one and only applying the necessary changes to the real DOM. This approach minimizes DOM manipulations and improves rendering performance." },
    { question: "What are the differences between class components and functional components prior to React Hooks?", answer: "Before the introduction of React Hooks, class components were used for stateful components with lifecycle methods. Functional components were stateless and used for rendering UI based on props. Class components had access to lifecycle methods like componentDidMount and setState, while functional components lacked state management capabilities." },
    { question: "Explain the concept of PureComponent in React. How does it differ from regular components?", answer: "PureComponent is a class component in React that implements shouldComponentUpdate with a shallow prop and state comparison to prevent unnecessary re-renders. It is useful for optimizing performance in applications where components render frequently." },
    { question: "What is the purpose of the useReducer hook in React?", answer: "The useReducer hook in React is used for managing complex state logic by specifying a reducer function. It returns the current state and a dispatch method to trigger state transitions based on dispatched actions. useReducer is an alternative to useState for managing state in functional components." },
    { question: "Explain the concept of CSS-in-JS in React. How is it implemented?", answer: "CSS-in-JS is a technique used to write CSS styles directly in JavaScript files within React components. It allows encapsulating styles and scoped CSS rules to specific components, improving modularity and reducing style conflicts. CSS-in-JS libraries like styled-components or Emotion provide APIs for defining styles using JavaScript objects or template literals." },
    { question: "What are Higher-Order Components (HOCs) in React? Provide an example.", answer: "Higher-Order Components (HOCs) are functions that take a component as an argument and return a new enhanced component with additional features or behaviors. They are used for code reuse, logic abstraction, and cross-cutting concerns like authentication or data fetching.\n\nExample:\nfunction withLogger(WrappedComponent) {\n    return function WithLogger(props) {\n        console.log(`Rendering ${WrappedComponent.name}`);\n        return <WrappedComponent {...props} />;\n    };\n}\nconst EnhancedComponent = withLogger(MyComponent);" },
    { question: "How does React handle forms? Explain controlled and uncontrolled components.", answer: "React handles forms using controlled and uncontrolled components. Controlled components bind form input values to state and update them via state handlers like onChange, providing full control over form state. Uncontrolled components rely on DOM refs to access form values, suitable for simple form inputs without complex state management." },
    { question: "What are React Hooks? Why were they introduced?", answer: "React Hooks are functions that enable functional components to use state and lifecycle features previously only available in class components. They were introduced to simplify component logic, encourage functional programming patterns, and improve code reusability in React applications. Commonly used hooks include useState, useEffect, useContext, and useReducer." },
    { question: "Explain the concept of server-side rendering (SSR) in React.", answer: "Server-side rendering (SSR) in React involves rendering React components on the server instead of the client's browser. SSR improves initial page load performance, enhances SEO, and ensures content is visible to users with slow network connections or disabled JavaScript. Libraries like Next.js provide SSR capabilities out of the box for React applications." },
    { question: "What is the purpose of the useMemo hook in React?", answer: "The useMemo hook in React is used for memoizing expensive calculations in functional components. It caches the result of a function and reuses the cached value unless its dependencies change. useMemo is useful for optimizing performance by preventing redundant computations on each render." },
    { question: "Explain the concept of error boundaries in React. How are they implemented?", answer: "Error boundaries in React are components that catch JavaScript errors anywhere in their child component tree and display fallback UI instead of crashing the entire application. They are implemented using componentDidCatch lifecycle method or static getDerivedStateFromError method. Error boundaries improve application stability and error handling." },
    { question: "What are the advantages of using functional components over class components in React?", answer: "Functional components offer several advantages over class components, including simpler syntax, better performance optimizations with React Hooks, improved readability, and easier testing. They encourage functional programming paradigms and align with modern JavaScript features like arrow functions and destructuring." },
    { question: "Explain the concept of code splitting in React. Why is it important?", answer: "Code splitting in React involves breaking down a large JavaScript bundle into smaller chunks to be loaded asynchronously. It improves initial page load performance by reducing the amount of JavaScript that needs to be downloaded and executed. React.lazy and dynamic import() syntax are commonly used for code splitting in React applications." },
    { question: "How does React context work? When would you use it?", answer: "React context provides a way to share data between components without manually passing props through every level of the component tree. It is useful for passing global data like themes, localization settings, or user authentication state. Context is particularly beneficial for reducing prop drilling in deeply nested component structures." },
    { question: "Explain the concept of unidirectional data flow in React.", answer: "Unidirectional data flow in React refers to the practice of data flowing in one directionâ€”from parent to child components. It helps maintain predictable state management and simplifies data flow in complex applications. Changes to data are propagated down the component hierarchy through props, enabling clearer data flow and component isolation." },
    { question: "What is the purpose of the React Router library? How is routing implemented in React applications?", answer: "React Router is a popular library for implementing client-side routing in React applications. It enables navigation between different components or pages without a full page reload. Routing in React is implemented using declarative Route components, Switch for defining exclusive routes, Link for navigation, and useParams for accessing route parameters." },
    { question: "What are the different types of loops in JavaScript?", answer: "JavaScript supports several types of loops including for loop, while loop, do...while loop, and for...in loop (used for iterating over object properties). Each loop type has its own use case and syntax for controlling iterations." },
    { question: "Explain the concept of event delegation in JavaScript.", answer: "Event delegation is a technique where a single event listener is attached to a parent element to manage events for all of its descendants. This optimizes performance by reducing the number of event listeners and is useful for dynamically created elements." },
    { question: "What are some commonly used array methods in JavaScript?", answer: "JavaScript provides a rich set of array methods like map, filter, reduce, forEach, find, and sort. These methods enable developers to manipulate and iterate over arrays efficiently, perform operations like mapping, filtering, reducing, searching, and sorting." },
    { question: "Describe the difference between map and forEach array methods.", answer: "`map` and `forEach` are both array iteration methods in JavaScript. `map` returns a new array with transformed elements based on a provided function, while `forEach` iterates over array elements and executes a function for each element without returning a new array." },
    { question: "What is the purpose of the `this` keyword in JavaScript?", answer: "The `this` keyword refers to the current execution context in JavaScript. Its value depends on how a function is called (e.g., as a method, standalone function, or constructor). `this` is dynamically bound and can change based on function invocation." },
    { question: "Explain the concept of function hoisting in JavaScript.", answer: "Function hoisting is a JavaScript behavior where function declarations are moved to the top of their containing scope during the compilation phase. This allows functions to be used before they are declared in the source code." },
    { question: "What is the difference between `let`, `const`, and `var` in JavaScript?", answer: "`let` and `const` have block scope, while `var` has function scope. `const` variables cannot be reassigned after declaration, whereas `let` variables can be reassigned. `let` and `const` are preferred over `var` due to their predictable scoping behavior." },
    { question: "Explain the box model in CSS.", answer: "The box model in CSS defines how elements are rendered on a web page. It consists of content, padding, border, and margin areas around an element. Understanding the box model is essential for layout and spacing control in CSS." },
    { question: "What is the purpose of the `display` property in CSS?", answer: "The `display` property in CSS specifies the rendering behavior of an element. Common values include `block` (elements that start on a new line and take full width), `inline` (elements that don't start on a new line and only occupy necessary width), `inline-block` (elements that behave like inline but can have block properties), and `none` (hides the element)." },
    { question: "Describe the CSS `position` property and its values.", answer: "The `position` property in CSS determines the positioning of an element relative to its containing element. Values include `static` (default positioning), `relative` (position relative to its normal position), `absolute` (position relative to its closest non-static ancestor), and `fixed` (position relative to the viewport). `position: sticky;` is also available for creating elements that stick to a specific position during scrolling." },
    { question: "What are pseudo-classes in CSS? Provide examples.", answer: "Pseudo-classes in CSS allow styling based on special states of an element that cannot be represented using regular selectors. Examples include `:hover` (styling when hovering over an element), `:focus` (styling when an element receives focus), `:nth-child` (selecting elements based on their position in a parent), and `:first-child` (selecting the first child element of its parent)." },
    { question: "Explain the concept of flexbox in CSS.", answer: "Flexbox is a layout model in CSS designed for creating flexible and responsive layouts. It allows distributing space among elements in a container and aligning them dynamically regardless of their size. Flexbox properties include `display: flex;`, `flex-direction`, `justify-content`, `align-items`, and `flex-grow`." },
    { question: "What is the purpose of the `z-index` property in CSS?", answer: "The `z-index` property in CSS controls the stacking order of positioned elements. It specifies the z-axis position of an element relative to other elements. Higher `z-index` values bring elements to the front, allowing precise control over element stacking in layered layouts." },
    { question: "Explain the concept of CSS specificity.", answer: "CSS specificity determines which styles are applied to an element when conflicting selectors target the same property. Specificity is calculated based on selector types (e.g., ID selectors > class selectors > element selectors) and can be overridden using `!important` or by increasing selector specificity." },
    { question: "What are some new features introduced in ES6 (ECMAScript 2015)?", answer: "ES6 introduced several new features including let and const for variable declarations, arrow functions, template literals, destructuring assignment, classes, modules, and promises for asynchronous programming." },
    { question: "Explain the difference between arguments and parameters in JavaScript functions.", answer: "Parameters are placeholders in function definitions, while arguments are the actual values passed to a function when it is called. Parameters are part of the function signature, while arguments are the values supplied during function invocation." },
    { question: "What are callback functions in JavaScript? Provide an example of using a callback.", answer: "Callback functions are functions passed as arguments to other functions to be executed later. They are commonly used in asynchronous operations like event handling, timers, and AJAX requests. Example: \n\nfunction fetchData(callback) {\n    // Simulating asynchronous data fetching\n    setTimeout(() => {\n        const data = 'Some fetched data';\n        callback(data);\n    }, 2000);\n}\n\nfunction processData(data) {\n    console.log('Processing data:', data);\n}\n\nfetchData(processData); // Output: 'Processing data: Some fetched data'" },
    { question: "What is the difference between synchronous and asynchronous JavaScript?", answer: "Synchronous JavaScript executes code sequentially, blocking further execution until each operation completes. Asynchronous JavaScript allows multiple operations to be executed concurrently, and the program continues to run without waiting for tasks to complete, using features like callbacks, promises, and async/await." },
    { question: "Explain how AJAX requests work in JavaScript.", answer: "AJAX (Asynchronous JavaScript and XML) allows making asynchronous HTTP requests from a web page without reloading the entire page. It uses the XMLHttpRequest object or the fetch API to send requests to a server and handle responses asynchronously." },
    { question: "What is the Fetch API in JavaScript? How is it used for making HTTP requests?", answer: "The Fetch API is a modern interface for fetching resources (like JSON data or images) across the network. It provides a simpler and more flexible way to make HTTP requests compared to the XMLHttpRequest object. The Fetch API returns a Promise that resolves to the Response object, allowing for easy data extraction." },
    { question: "What is Axios? How does it simplify HTTP requests in JavaScript?", answer: "Axios is a popular library for making HTTP requests in JavaScript applications. It provides an easy-to-use API for performing GET, POST, PUT, DELETE, and other HTTP operations. Axios simplifies error handling, supports request cancellation, and provides options for intercepting requests and responses." },
    { question: "What is Vite in the context of JavaScript development?", answer: "Vite is a build tool that focuses on providing a fast development server and optimized production build for modern JavaScript projects. It leverages ES Modules for faster builds and supports hot module replacement (HMR) for instant updates during development. Vite is commonly used with frameworks like Vue.js and React." },
    { question: "Explain the concept of lexical scope in JavaScript.", answer: "Lexical scope in JavaScript means that the scope of a variable is determined by its position within the source code. Nested functions have access to variables defined in their outer (enclosing) scope." },
    { question: "What is hoisting in JavaScript? How does it affect variable declarations and function definitions?", answer: "Hoisting is a JavaScript behavior where variable declarations (using var) and function declarations are moved to the top of their containing scope during the compilation phase. This allows variables and functions to be used before they are declared in the source code." },
    { question: "What are the differences between function declarations and function expressions in JavaScript?", answer: "Function declarations are defined using the function keyword followed by a name and a function body. They are hoisted and can be used before they are declared. Function expressions, on the other hand, are defined using a variable and an anonymous function assigned to it. They are not hoisted and can only be used after they are defined." },
    { question: "Explain the concept of closures in JavaScript. Provide an example.", answer: "Closures are functions that retain access to variables from their lexical scope even after the outer function has finished executing. They 'close over' the variables they need. Example: \n\nfunction outer() {\n    const name = 'John';\n    return function inner() {\n        console.log('Hello, ' + name);\n    };\n}\n\nconst greeting = outer();\ngreeting(); // Output: 'Hello, John'" },
    { question: "What are arrow functions in JavaScript? How do they differ from regular functions?", answer: "Arrow functions are a concise syntax for writing functions in JavaScript. They do not have their own 'this' context and cannot be used as constructors. Arrow functions are more suitable for non-method functions and provide implicit return for single expressions. Example: \n\nconst add = (a, b) => a + b;\nconsole.log(add(3, 5)); // Output: 8" },
    { question: "Explain the concept of 'this' in JavaScript. How does it differ in arrow functions?", answer: "'this' in JavaScript refers to the current execution context. In regular functions, 'this' is dynamically scoped and determined by how the function is called. In arrow functions, 'this' is lexically scoped and inherits the value of 'this' from its enclosing context." },
    { question: "What are class components in React? How do they differ from functional components?", answer: "Class components in React are ES6 classes that extend React.Component. They have access to state and lifecycle methods such as componentDidMount and render. Functional components are simple JavaScript functions that take props as arguments and return JSX elements. With the introduction of React Hooks, functional components can also manage state and lifecycle using useState and useEffect." },
    { question: "Explain the concept of objects in JavaScript. How are they different from arrays?", answer: "Objects in JavaScript are collections of key-value pairs where keys are strings (or Symbols) and values can be any data type. Arrays are ordered collections of elements accessed by numeric indices. Objects are used for storing structured data and representing real-world entities, while arrays are used for storing lists of items and iterating over them." },
    { question: "What is JSON? How is it related to JavaScript?", answer: "JSON (JavaScript Object Notation) is a lightweight data interchange format used to represent data as text. It is language-independent and easy for humans to read and write. JSON is derived from JavaScript object literals and is commonly used for data transmission between a server and a web application." },
    { question: "Explain the concept of boolean values in JavaScript. What are truthy and falsy values?", answer: "Boolean values in JavaScript represent true or false. JavaScript has 'truthy' and 'falsy' values, where values that are considered 'falsy' (e.g., false, 0, '', null, undefined, NaN) evaluate to false in a boolean context, and all other values are 'truthy'." },
    { question: "What are methods in JavaScript? How do they differ from functions?", answer: "Methods in JavaScript are functions that are properties of objects. They can be invoked using dot notation on object instances. Functions, on the other hand, are standalone blocks of reusable code that can be called with or without an object context." },
];

const flashcardContainer = document.getElementById('flashcardContainer');
const nextButton = document.getElementById('nextButton');
const randomButton = document.getElementById('randomButton');

function createFlashcard(question, answer) {
    const flashcard = document.createElement('div');
    flashcard.classList.add('flashcard-container');
    flashcard.innerHTML = `
        <div class="flashcard">
            <div class="front">${question}</div>
            <div class="back">${answer}</div>
        </div>
    `;

    // Event listener for the entire flashcard
    flashcard.addEventListener('click', () => {
        flashcard.classList.toggle('flipped');
    });

    return flashcard;
}

function loadNextFlashcard() {
    if (currentCardIndex < flashcards.length) {
        const { question, answer } = flashcards[currentCardIndex];
        const flashcard = createFlashcard(question, answer);
        flashcardContainer.innerHTML = '';
        flashcardContainer.appendChild(flashcard);
        currentCardIndex++;
    } else {
        flashcardContainer.innerHTML = '<div class="flashcard-container"><div class="flashcard"><div class="front">No more flashcards!</div></div></div>';
    }
}

function loadRandomFlashcard() {
    const randomIndex = Math.floor(Math.random() * flashcards.length);
    const { question, answer } = flashcards[randomIndex];
    const flashcard = createFlashcard(question, answer);
    flashcardContainer.innerHTML = '';
    flashcardContainer.appendChild(flashcard);
}

// Event listener for the Next button
nextButton.addEventListener('click', loadNextFlashcard);
randomButton.addEventListener('click', loadRandomFlashcard);

// Initial load of the first flashcard
loadNextFlashcard();